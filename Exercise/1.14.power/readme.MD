# [1.14] 

教材上给出的推导过程，看了n久看不懂，我这个智力就到这了。。。

一直看一直看一直看，终于有一天5环TMD修到了7环！懂了。。。

```c++
__int64 power2_I(int n)
{
	__int64 pow = 1;
	__int64 p = 2;

	while (n) {
		if (n & 1) { pow *= p; }
		n >>= 1;
		p *= p;
	}

	return pow;
}
```

代码如是，理解起来可真要我老命。

以 `2^10` 为例，

    10 = b(1010)

    2^10 = (2^(2^3))^1 * (2^(2^2))^0 * (2^(2^1))^1 * (2^(2^0))^0

    假设计算 2^n， n有k个比特位，f(k)表示数字n的第k个字节的值（1或0），对本例n=10, k=4，则

    2^n = (2^(2^k))^f(k) * (2^(2^(k-1)))^f(k-1) * ... * (2^(2^0))^f(0)

    设 g(k)=2^(2^k)，则：

    2^n = g(k)^f(k) * g(k-1)^f(k-1) * ... * g(0)^f(0)

    可见 g(k) = g(k-1) ^ 2

    因此：

```c++
__int64 power2_I(int n)
{
    __int64 pow = 1; // 结果
    __int64 p = 2; // 累乘项初始化为2，即g(k)

    while (n) { // 迭代 log(n)轮
        if (n & 1) { pow *= p; } // 当f(k)为1时，将g(k)计入结果
        n >>= 1;
        p *= p; // g(k) = g(k-1) ^ 2
    }

    return pow;
}
```

嗯，我这个智力也就到这了。。。

扩展到a^n，

同样有：

    a^n = g(k)^f(k) * g(k-1)^f(k-1) * ... * g(0)^f(0)，其中，g(k) = a^(a^k)

因此：

```c
__int64 power(__int64 a, int n)
{
	__int64 pow = 1;
	__int64 p = a;
	while (n) {
		if (n & 1) { pow *= p; }
		n >>= 1;
		p *= p;
	}
	return pow;
}
```